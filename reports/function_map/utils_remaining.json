{
  "directory": "src/utils",
  "generatedAt": "2025-09-13T08:21:10+02:00",
  "files": {
    "rdfParser.ts": {
      "file": "src/utils/rdfParser.ts",
      "exports": [
        "parseRDFFile",
        "RDFParser",
        "ParsedGraph",
        "GraphNode",
        "GraphEdge"
      ],
      "functions": [
        {
          "name": "parseRDFFile",
          "signature": "async (content: string, onProgress?: (progress:number, message:string)=>void) => Promise<ParsedGraph>",
          "description": "Convenience wrapper that instantiates RDFParser and runs parseRDF on provided content. Produces a ParsedGraph (nodes, edges, namespaces, prefixes)."
        },
        {
          "name": "RDFParser.parseRDF",
          "signature": "async (rdfContent: string, onProgress?: fn) => Promise<ParsedGraph>",
          "description": "Top-level parsing routine. Detects RDF/XML vs Turtle/JSON-LD, sets base prefixes, uses N3.Parser by default and delegates to parseRdfXml for RDF/XML. Collects prefixes/namespaces, then calls extractGraph to produce a ParsedGraph structure. Reports progress via onProgress callback."
        },
        {
          "name": "RDFParser.parseRdfXml (private)",
          "signature": "private (rdfXml: string, onProgress?: fn) => Promise<ParsedGraph>",
          "description": "Browser DOM-based RDF/XML parser (best-effort). Extracts namespace declarations, iterates elements to create triples for rdf:resource, rdf:nodeID, typed literals and implicit rdf:type via element names. Adds quads into internal N3 store then delegates to extractGraph."
        },
        {
          "name": "RDFParser.extractGraph (private)",
          "signature": "private (onProgress?: fn) => ParsedGraph",
          "description": "Walks the N3 store to identify rdf:type subjects, build canonical GraphNode entries (literal/annotation properties normalization), derive GraphEdge entries for object properties, build namespaces/prefixes for output. Normalizes nodes to canonical UI shape (iri, type, annotations)."
        },
        {
          "name": "RDFParser.splitUri / createShortPrefix / createSafeId / shortenUri (private)",
          "signature": "helpers",
          "description": "URI utilities used during parsing: split URIs to namespace/localName (prefer existing prefixes), create short prefixes for unknown namespaces, produce DOM-safe ids, and shorten IRIs using known prefixes."
        }
      ],
      "notes": "RDFParser centralizes RDF->graph extraction used by ontologyStore and rdfManager. Duplication candidates: namespace/prefix inference and node/edge normalization logic also appears in ontologyStore/rdfManager; consider centralizing canonical node-shaping and prefix utilities."
    },
    "termDisplay.ts": {
      "file": "src/utils/termDisplay.ts",
      "exports": [
        "shortLocalName",
        "findPrefixForUri",
        "toPrefixed",
        "expandPrefixed",
        "computeTermDisplay",
        "TermDisplayInfo"
      ],
      "functions": [
        {
          "name": "shortLocalName",
          "signature": "(uriOrPrefixed?: string) => string",
          "description": "Returns a best-effort local name for a URI or prefixed form (splits on # or / or ':'), used for UI labels when full prefix resolution isn't required."
        },
        {
          "name": "findPrefixForUri",
          "signature": "(fullUri: string, rdfManager?: RDFManager | Record<string,string>) => string | undefined",
          "description": "Finds a configured prefix that matches the provided full IRI using the supplied rdfManager or namespace map."
        },
        {
          "name": "toPrefixed",
          "signature": "(iri: string | NamedNode, rdfManager?: RDFManager | Record<string,string>) => string",
          "description": "Converts a full IRI to a prefix:local form; throws if no matching prefix exists (strict behaviour)."
        },
        {
          "name": "expandPrefixed",
          "signature": "(prefixedOrIri: string, rdfManager?: RDFManager | Record<string,string>) => string",
          "description": "Expands a prefixed name into a full IRI. Prefers rdfManager.expandPrefix when available, otherwise uses provided namespace map. Throws on failure (strict)."
        },
        {
          "name": "computeTermDisplay",
          "signature": "(iriOrTerm: string | NamedNode, rdfManager?: RDFManager | Record<string,string>) => TermDisplayInfo",
          "description": "Produces a strict TermDisplayInfo object (iri, prefixed, short, namespace, tooltipLines). Requires a namespace map or RDFManager; throws if a prefixed token cannot be expanded. Used by UI components to present concise labels and tooltips."
        }
      ],
      "notes": "This module provides strict, centralized term display logic. It intentionally throws when prefixes are missing to force explicit namespace handling. Good candidate to be the single source of truth for prefix expansion across stores and utils."
    },
    "wellKnownOntologies.ts": {
      "file": "src/utils/wellKnownOntologies.ts",
      "exports": [
        "WELL_KNOWN_PREFIXES",
        "WELL_KNOWN_BY_PREFIX",
        "WELL_KNOWN_BY_URL",
        "WELL_KNOWN"
      ],
      "constants": [
        {
          "name": "WELL_KNOWN_PREFIXES",
          "description": "Array of canonical prefix metadata ({prefix, url, name}). Primary data source for well-known prefixes and ontologies."
        },
        {
          "name": "WELL_KNOWN_BY_PREFIX",
          "description": "Derived record keyed by prefix for quick lookup."
        },
        {
          "name": "WELL_KNOWN_BY_URL",
          "description": "Map from namespace URL -> array of prefixes that point to it."
        },
        {
          "name": "WELL_KNOWN",
          "description": "Backwards-compatible object with `prefixes` and `ontologies` keys used by other modules for convenience."
        }
      ],
      "notes": "Centralized canonical store for prefixes and 'well-known' ontology metadata. Modules performing prefix expansion or matching should rely on this module or a single derived namespace map to avoid drift."
    }
  },
  "missing": {
    "uriShortener.ts": {
      "expected_path": "src/utils/uriShortener.ts",
      "status": "not found",
      "note": "The earlier file index referenced src/utils/uriShortener.ts but it is not present in the repository. If this file exists elsewhere or under a different name, point me to it and I will include it in the utility reports."
    }
  },
  "global_notes": [
    "Completed scanning of requested utils: rdfManager, rdfParser, termDisplay, wellKnownOntologies.",
    "Duplication hotspots observed across utils and stores:",
    "- Prefix expansion / expandPrefix / toPrefixed implemented in multiple places (rdfManager, termDisplay, ontologyStore, reasoningStore). Centralize into a single utility (e.g., termDisplay.expand / rdfUtils.expand) and have rdfManager call it.",
    "- Node/edge normalization and annotation/literal handling appears in rdfParser.applyParsedNodes, rdfManager.applyParsedNodes, ontologyStore merging, and reasoningStore normalization helpers. Consolidate canonical node-shaping & identity resolution into a shared module (e.g., utils/nodeShape.ts).",
    "- extractReferencedOntologies logic exists in both rdfManager and ontologyStore with slight differences; unify into a single heuristic function.",
    "- Inference persistence and RDF write paths are implemented in multiple locations (reasoningStore directly writing quads, rdfManager.updateNode/addQuad). Route all quad persistence through rdfManager APIs to ensure consistent graph naming and subject notifications.",
    "",
    "Next recommended steps:",
    "1) If you want, I can continue scanning remaining files and produce per-file JSON reports the same way.",
    "2) Alternatively, I can generate a consolidated index file listing all reports created so far (reports/function_map/*.json) for easier review.",
    "3) If you prefer, I can start proposing concrete refactor patches to deduplicate specific utilities (example: extract a shared prefix-expansion module and update callers)."
  ]
}
