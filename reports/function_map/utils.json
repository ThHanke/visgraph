{
  "directory": "src/utils",
  "generatedAt": "2025-09-13T07:57:21+02:00",
  "files": {
    "termDisplay.ts": {
      "path": "src/utils/termDisplay.ts",
      "functions": [
        {
          "name": "shortLocalName",
          "exported": true,
          "signature": "shortLocalName(uriOrPrefixed?: string): string",
          "description": "Return a short/local name for a URI or prefixed name. Handles full IRIs (splits on '#' or '/'), prefixed names (returns part after ':'), and fallbacks to the last segment. Returns empty string for falsy input."
        },
        {
          "name": "resolveNamespaces",
          "exported": false,
          "signature": "resolveNamespaces(mgr?: RDFManager | { getNamespaces?: () => Record<string,string> } | Record<string,string> | undefined): Record<string,string>",
          "description": "Internal helper. Resolves a namespace map from either an RDFManager-like object (calls getNamespaces) or a raw map. Throws when no resolver provided or invalid input."
        },
        {
          "name": "findPrefixForUri",
          "exported": true,
          "signature": "findPrefixForUri(fullUri: string, rdfManager?: RDFManager | Record<string,string>): string | undefined",
          "description": "Finds a registered prefix whose namespace URI is a prefix of the given full IRI. Uses the provided rdfManager or namespace map. Returns the prefix string or undefined if none found."
        },
        {
          "name": "toPrefixed",
          "exported": true,
          "signature": "toPrefixed(iri: string | NamedNode, rdfManager?: RDFManager | Record<string,string>): string",
          "description": "Converts a full IRI to a strict prefixed form (prefix:local). Requires a namespace map or rdfManager with matching prefix; throws if no prefix known. Passes through blank-node labels (starting with '_:')."
        },
        {
          "name": "expandPrefixed",
          "exported": true,
          "signature": "expandPrefixed(prefixedOrIri: string, rdfManager?: RDFManager | Record<string,string>): string",
          "description": "Expands a prefixed name to a full IRI. If the value already contains '://' it's returned unchanged. If rdfManager has expandPrefix it is used; otherwise the provided namespace map is used. Throws on unknown prefix or invalid input. Blank-node passthrough supported."
        },
        {
          "name": "computeTermDisplay",
          "exported": true,
          "signature": "computeTermDisplay(iriOrTerm: string | NamedNode, rdfManager?: RDFManager | Record<string,string>): TermDisplayInfo",
          "description": "Main strict term display function. Produces TermDisplayInfo (iri, prefixed, short, namespace, tooltipLines). Accepts a NamedNode or string, expands prefixed names when rdfManager provided, throws for missing prefixes unless blank node. Prefers producing prefix:local when possible, otherwise falls back to local name."
        }
      ]
    },
    "rdfManager.ts": {
      "path": "src/utils/rdfManager.ts",
      "functions": [
        {
          "name": "RDFManager (class)",
          "exported": true,
          "signature": "class RDFManager { ... }",
          "description": "Encapsulates RDF store operations using N3.Store. Manages namespaces, parsing/loading RDF (various formats), export, namespace management, and change notifications. Provides subject-level change coalescing and blacklist handling. The file exports both the class and a singleton instance 'rdfManager'."
        },
        {
          "name": "constructor",
          "exported": false,
          "signature": "constructor()",
          "description": "Initializes store, parser, writer, default namespaces, optional write-tracing hooks and runtime helpers exposed on window. Also prepares internal subscription and blacklist state."
        },
        {
          "name": "getBlacklist",
          "exported": true,
          "signature": "getBlacklist(): { prefixes: string[]; uris: string[] }",
          "description": "Return current configured blacklist for prefixes and absolute namespace URIs."
        },
        {
          "name": "setBlacklist",
          "exported": true,
          "signature": "setBlacklist(prefixes: string[] | undefined | null, uris?: string[] | undefined | null): void",
          "description": "Set/replace blacklist prefixes and URIs; attempts best-effort persistence into appConfig store when available."
        },
        {
          "name": "isBlacklistedIri",
          "exported": false,
          "signature": "isBlacklistedIri(val?: string | null): boolean",
          "description": "Internal predicate to determine whether an IRI or prefixed name should be considered blacklisted based on configured prefixes, URIs, and well-known mappings."
        },
        {
          "name": "onChange",
          "exported": true,
          "signature": "onChange(cb: (count: number) => void): void",
          "description": "Subscribe to a simple change counter that increments each time the store mutates in a way the manager considers noteworthy."
        },
        {
          "name": "offChange",
          "exported": true,
          "signature": "offChange(cb: (count: number) => void): void",
          "description": "Unsubscribe from change notifications."
        },
        {
          "name": "notifyChange",
          "exported": false,
          "signature": "notifyChange(): void",
          "description": "Internal helper that increments the change counter and invokes change subscribers while isolating subscriber errors."
        },
        {
          "name": "onSubjectsChange",
          "exported": true,
          "signature": "onSubjectsChange(cb: (subjects: string[]) => void): void",
          "description": "Subscribe to subject-level change notifications; callbacks will receive an array of unique subject IRIs affected (coalesced, debounced)."
        },
        {
          "name": "offSubjectsChange",
          "exported": true,
          "signature": "offSubjectsChange(cb: (subjects: string[]) => void): void",
          "description": "Unsubscribe subject-level change listener."
        },
        {
          "name": "scheduleSubjectFlush",
          "exported": false,
          "signature": "scheduleSubjectFlush(delay = 50): void",
          "description": "Internal debounced flusher that emits subject-level changes to subscribers after a short delay."
        },
        {
          "name": "bufferSubjectFromQuad",
          "exported": false,
          "signature": "bufferSubjectFromQuad(q: Quad | null | undefined): void",
          "description": "Internal helper that buffers subjects from added/removed quads unless blacklisted, and schedules flush."
        },
        {
          "name": "loadRDF",
          "exported": true,
          "signature": "loadRDF(rdfContent: string, mimeType?: string): Promise<void>",
          "description": "Parse and load RDF content into the default graph. Supports RDF/XML via streaming parser and Turtle/TLL/other via N3.Parser. Deduplicates concurrent identical loads, preserves parsed prefixes, emits change notifications and records debug info. Rejects/throws on fatal parser errors."
        },
        {
          "name": "loadRDFIntoGraph",
          "exported": true,
          "signature": "loadRDFIntoGraph(rdfContent: string, graphName?: string, mimeType?: string): Promise<void>",
          "description": "Same as loadRDF but stores quads into the named graph 'graphName' when provided. Handles RDF/XML streaming parser and N3.Parser paths similarly."
        },
        {
          "name": "updateNode",
          "exported": true,
          "signature": "updateNode(entityUri: string, updates: { type?: string; rdfTypes?: string[]; annotationProperties?: any[] }, options?: { preserveExistingLiterals?: boolean; notify?: boolean }): void",
          "description": "Idempotently update an entity's rdf:type triples and annotation literal properties. Supports 'replacement' or 'additive' modes for literals (preserveExistingLiterals). Expands prefixes, avoids duplicate additions, and buffers subject-level notifications. Notifies subscribers after update unless explicitly suppressed."
        },
        {
          "name": "loadFromUrl",
          "exported": true,
          "signature": "loadFromUrl(url: string, options?: { timeoutMs?: number; onProgress?: (progress: number, message: string) => void }): Promise<{ content: string; mimeType: string | null }>",
          "description": "Fetch a URL with Accept headers and timeout. Uses heuristics to decide whether fetched content looks like RDF; retries with a dev-server proxy fallback (/__external) to bypass CORS. Records structured debug info and throws when both direct and proxy attempts fail."
        },
        {
          "name": "exportToTurtle / exportToJsonLD / exportToRdfXml",
          "exported": true,
          "signature": "exportToTurtle(): Promise<string> (and similar for JSON-LD and RDF/XML)",
          "description": "Export the current store to Turtle / JSON-LD / RDF/XML using N3.Writer with current namespaces. Return formatted string promises."
        },
        {
          "name": "getNamespaces",
          "exported": true,
          "signature": "getNamespaces(): Record<string, string>",
          "description": "Return the current namespace/prefix mapping held by the manager."
        },
        {
          "name": "addNamespace",
          "exported": true,
          "signature": "addNamespace(prefix: string, uri: string): void",
          "description": "Add or update a namespace mapping. When a new mapping is added, show a UI toast asynchronously (dynamic import) to notify user. Idempotent behavior for existing mappings."
        },
        {
          "name": "removeNamespaceAndQuads",
          "exported": true,
          "signature": "removeNamespaceAndQuads(prefixOrUri: string): void",
          "description": "Remove a namespace (by prefix or URI) and best-effort remove any quads where subject/predicate/object starts with that namespace URI. Attempts to remove mappings and related quads."
        },
        {
          "name": "removeGraph",
          "exported": true,
          "signature": "removeGraph(graphName: string): void",
          "description": "Remove all quads in the named graph (idempotent) and notify subscribers."
        },
        {
          "name": "removeQuadsInGraphByNamespaces",
          "exported": true,
          "signature": "removeQuadsInGraphByNamespaces(graphName: string, namespaceUris?: string[] | null): void",
          "description": "Remove quads inside a specific named graph that match any of the provided namespace URIs. Useful to remove an ontology's quads from a shared graph."
        },
        {
          "name": "expandPrefix",
          "exported": true,
          "signature": "expandPrefix(prefixedUri: string): string",
          "description": "Expand a prefixed form (prefix:local) to a full IRI using registered namespaces. If unknown prefix and recognized well-known fallback exists (dc), add it and expand. Otherwise returns original input."
        },
        {
          "name": "getStore",
          "exported": true,
          "signature": "getStore(): Store",
          "description": "Return the underlying N3.Store instance for direct access."
        },
        {
          "name": "clear",
          "exported": true,
          "signature": "clear(): void",
          "description": "Reinitialize the store to empty and restore core RDF prefixes (rdf/rdfs/owl/xsd). Notify subscribers."
        },
        {
          "name": "applyParsedNamespaces",
          "exported": true,
          "signature": "applyParsedNamespaces(namespaces: Record<string,string> | undefined | null): void",
          "description": "Merge parsed namespace mappings into manager using addNamespace for each entry (ensures toast/consistency and idempotency)."
        },
        {
          "name": "applyParsedNodes",
          "exported": true,
          "signature": "applyParsedNodes(parsedNodes: any[] | undefined | null, options?: { preserveExistingLiterals?: boolean }): void",
          "description": "Bulk-apply parsed node data (rdfTypes and literal/annotation properties) idempotently. Internally calls updateNode. Notifies subscribers once after bulk apply."
        },
        {
          "name": "extractReferencedOntologies",
          "exported": true,
          "signature": "extractReferencedOntologies(rdfContent: string): string[]",
          "description": "Scan RDF content for namespace declarations/prefix usage and return a list of well-known ontology URIs that the content references. Useful to suggest which ontologies to load."
        }
      ]
    },
    "theme.ts": {
      "path": "src/utils/theme.ts",
      "functions": [
        {
          "name": "getStoredTheme",
          "exported": false,
          "signature": "getStoredTheme(): 'light'|'dark'|'system' | null",
          "description": "Read persisted theme preference from localStorage. Returns null on errors or when no valid stored value."
        },
        {
          "name": "prefersSystemDark",
          "exported": false,
          "signature": "prefersSystemDark(): boolean",
          "description": "Query the browser prefers-color-scheme media query to determine if system preference is dark. Safe-checks when window is undefined."
        },
        {
          "name": "applyTheme",
          "exported": true,
          "signature": "applyTheme(theme: 'light'|'dark'|'system'): void",
          "description": "Apply theme by toggling the document.documentElement .dark CSS class and setting data-theme attribute. Resolves 'system' via prefersSystemDark()."
        },
        {
          "name": "setTheme",
          "exported": true,
          "signature": "setTheme(theme: 'light'|'dark'|'system'): void",
          "description": "Persist chosen theme to localStorage (best-effort) and immediately apply it."
        },
        {
          "name": "initTheme",
          "exported": true,
          "signature": "initTheme(): void",
          "description": "Initialize theme on startup: apply persisted preference or fallback to system. If using system preference, attach a listener to react to system changes (handles older/newer browsers)."
        }
      ]
    },
    "startupDebug.ts": {
      "path": "src/utils/startupDebug.ts",
      "functions": [
        {
          "name": "nowIso",
          "exported": false,
          "signature": "nowIso(): string",
          "description": "Return current ISO timestamp string. Internal helper."
        },
        {
          "name": "ensureSummary",
          "exported": false,
          "signature": "ensureSummary(): any",
          "description": "Ensure and return the global debug summary object on window.__VG_DEBUG_SUMMARY__, initializing default structure when needed. Safe for non-browser environments (returns an object)."
        },
        {
          "name": "makeFingerprint",
          "exported": false,
          "signature": "makeFingerprint(eventName: string, meta?: Record<string, any>): string",
          "description": "Create a short fingerprint string for duplicate-detection using common keys (id/key/iri/name) or a small meta signature."
        },
        {
          "name": "recordRecentEvent",
          "exported": false,
          "signature": "recordRecentEvent(fp: string, caller?: string): any[]",
          "description": "Push a fingerprint into a recent events buffer and return occurrences for that fingerprint within a short window. Used by fallback() duplicate detection."
        },
        {
          "name": "captureFullStack",
          "exported": false,
          "signature": "captureFullStack(): string|undefined",
          "description": "Return a captured full stack string from a new Error, or undefined on failure."
        },
        {
          "name": "safeConsole",
          "exported": false,
          "signature": "safeConsole(level: 'debug'|'info'|'warn'|'error', ...args: any[]): void",
          "description": "Wrapper around console.* that guards against console being unavailable or throwing."
        },
        {
          "name": "shortCaller",
          "exported": false,
          "signature": "shortCaller(stackLimit = 2): string | null",
          "description": "Inspect current stack and return a short caller identifier in the form file:line for the first suitable frame, skipping internal logger frames."
        },
        {
          "name": "incr",
          "exported": true,
          "signature": "incr(counterName: string, n?: number): void",
          "description": "Increment an internal counter in the global debug summary (used for lightweight metrics)."
        },
        {
          "name": "milestone",
          "exported": true,
          "signature": "milestone(name: string, meta?: Record<string, any>): void",
          "description": "Record a named milestone (timestamp + meta) into the debug summary and optionally log to console when debug gate enabled."
        },
        {
          "name": "log",
          "exported": true,
          "signature": "log(level: 'debug'|'info'|'warn'|'error', eventName: string, meta?: Record<string, any>, options?: { caller?: boolean }): void",
          "description": "Core structured logging function that stores entries in the debug summary and conditionally outputs to console when debug gate enabled. Optionally records caller."
        },
        {
          "name": "debug / info / warn / error",
          "exported": true,
          "signature": "debug(event: string, meta?: any, options?: { caller?: boolean }) etc.",
          "description": "Convenience wrappers around log() for each log level."
        },
        {
          "name": "timedAsync",
          "exported": true,
          "signature": "timedAsync<T>(eventName: string, meta: any | undefined, fn: () => Promise<T>, options?: { caller?: boolean }): Promise<T>",
          "description": "Run an async function while recording start/end debug entries and duration. Emits .start, .end or .error events to the summary."
        },
        {
          "name": "fallback",
          "exported": true,
          "signature": "fallback(eventName: string, meta?: any, options?: { level?: 'warn'|'error'|'info'; captureStack?: boolean; caller?: boolean }): void",
          "description": "Structured gated fallback/error recording. Records entries in summary.fallbacks with duplicate-detection and optional stack capture. Console output controlled by debug gate."
        },
        {
          "name": "debugLog (alias)",
          "exported": true,
          "signature": "const debugLog = debug",
          "description": "Alias kept for compatibility with older instrumentation; points to debug()."
        },
        {
          "name": "getSummary",
          "exported": true,
          "signature": "getSummary(): any",
          "description": "Return a deep-cloned snapshot of the current debug summary for external tooling."
        }
      ]
    },
    "wellKnownOntologies.ts": {
      "path": "src/utils/wellKnownOntologies.ts",
      "exports": [
        "WELL_KNOWN_PREFIXES",
        "WELL_KNOWN_BY_PREFIX",
        "WELL_KNOWN_BY_URL",
        "WELL_KNOWN"
      ],
      "description": "Provides canonical well-known ontology/prefix mappings. Exports an array of canonical prefix metadata and derived lookup objects/maps for convenience. Notable exports are static constants rather than functions."
    }
  }
}
