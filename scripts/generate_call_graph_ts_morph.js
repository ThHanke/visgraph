#!/usr/bin/env node
/**
 * AST call graph generator using ts-morph (better symbol resolution).
 *
 * - Requires dev dependency "ts-morph" (already installed by earlier step).
 * - Scans src/ for TS/JS files, resolves call expressions to declarations where possible.
 * - Emits docs/call_graph.generated.json
 *
 * This is a conservative generator — symbol resolution may still fall back to callee text when resolution fails.
 */

import fs from "fs";
import path from "path";
import { Project, SyntaxKind } from "ts-morph";

const ROOT = process.cwd();
const SRC = path.join(ROOT, "src");
const OUT = path.join(ROOT, "docs", "call_graph.generated.json");

function walkFiles(dir) {
  const results = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) results.push(...walkFiles(full));
    else if (entry.isFile() && /\.(ts|tsx|js|jsx)$/.test(entry.name)) results.push(full);
  }
  return results;
}

function normalizePath(p) {
  return path.relative(ROOT, p).replace(/\\/g, "/");
}

(async () => {
  const project = new Project({
    tsConfigFilePath: undefined,
    skipAddingFilesFromTsConfig: true,
    compilerOptions: { allowJs: true, checkJs: false, jsx: 2 }
  });

  const files = walkFiles(SRC);
  project.addSourceFilesAtPaths(files);

  const defs = new Map(); // symbolId -> { name, definedIn: Set }
  const calls = new Map(); // calleeKey -> Set of locations

  function recordDef(name, filePath) {
    const key = name || "(anonymous)";
    if (!defs.has(key)) defs.set(key, { name: key, definedIn: new Set() });
    defs.get(key).definedIn.add(normalizePath(filePath));
  }

  function recordCall(calleeKey, filePath, line, col) {
    if (!calls.has(calleeKey)) calls.set(calleeKey, new Set());
    calls.get(calleeKey).add(`${normalizePath(filePath)}:${line}:${col}`);
  }

  for (const sf of project.getSourceFiles()) {
    try {
      // collect top-level function/class names as definitions
      sf.forEachChild((node) => {
        if (node.getKind && (node.getKind() === SyntaxKind.FunctionDeclaration || node.getKind() === SyntaxKind.ClassDeclaration)) {
          const nameNode = typeof node.getName === "function" ? node.getName() : undefined;
          if (nameNode) recordDef(nameNode, sf.getFilePath());
        }
      });

      // walk calls
      const callsExpr = sf.getDescendantsOfKind(SyntaxKind.CallExpression);
      for (const cexpr of callsExpr) {
        // callee expression text
        const expr = cexpr.getExpression();
        const calleeText = expr.getText();
        const { line, column } = cexpr.getStartLinePos();

        // Try to resolve symbol
        let resolvedName = calleeText;
        try {
          const symbol = expr.getSymbol();
          if (symbol) {
            // Prefer first declaration name or symbol.getName()
            const symName = symbol.getName();
            const decls = symbol.getDeclarations();
            const declFiles = decls.map(d => d.getSourceFile().getFilePath()).filter(Boolean);
            resolvedName = symName || calleeText;
            recordDef(resolvedName, declFiles[0] || sf.getFilePath());
            // record call under symbolic name to allow grouping
            recordCall(resolvedName, sf.getFilePath(), line, column);
            continue;
          }
        } catch (e) {
          // resolution failed — fall back to text
        }

        // fallback: record by calleeText (property access and others)
        recordCall(calleeText, sf.getFilePath(), line, column);
      }
    } catch (e) {
      // non-fatal
      // console.warn('Failed to process', sf.getFilePath(), e && e.message);
    }
  }

  // Build combined functions array
  const mapOut = new Map();

  // Add defs
  for (const [k, v] of defs.entries()) {
    mapOut.set(k, { name: v.name, definedIn: Array.from(v.definedIn).sort(), role: "", callSites: [] });
  }

  // Add calls
  for (const [callee, sites] of calls.entries()) {
    if (mapOut.has(callee)) {
      const entry = mapOut.get(callee);
      entry.callSites.push(...Array.from(sites));
      mapOut.set(callee, entry);
    } else {
      mapOut.set(callee, { name: callee, definedIn: [], role: "", callSites: Array.from(sites) });
    }
  }

  const functions = Array.from(mapOut.values()).map(f => ({
    name: f.name,
    definedIn: f.definedIn && f.definedIn.length ? f.definedIn : ['unknown'],
    role: f.role || '',
    callSites: Array.from(new Set(f.callSites || [])).sort()
  }));

  const out = {
    generatedAt: new Date().toISOString(),
    note: "Generated by scripts/generate_call_graph_ts_morph.js — ts-morph-based mapping (symbol resolution). This remains conservative and may still include unknown/ambiguous entries.",
    functions
  };

  fs.mkdirSync(path.dirname(OUT), { recursive: true });
  fs.writeFileSync(OUT, JSON.stringify(out, null, 2), "utf8");
  console.log("Wrote", OUT, "with", functions.length, "entries");
})();
