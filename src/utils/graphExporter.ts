// Support for both React Flow and  data formats
interface ReactFlowNode {
  id: string;
  data: any;
}

interface ReactFlowEdge {
  id: string;
  source: string;
  target: string;
  data?: any;
}

//  uses plain objects with different structure
interface Node {
  key: string;
  classType: string;
  individualName: string;
  namespace: string;
  literalProperties: { key: string; value: string; type?: string }[];
}

interface Link {
  from: string;
  to: string;
  label: string;
  propertyType: string;
  namespace: string;
}

interface ExportOptions {
  format: 'turtle' | 'owl-xml' | 'json-ld';
  includeNamespaces: boolean;
  includeMetadata: boolean;
}

export class GraphExporter {
  private static getNamespaces(): Record<string, string> {
    return {
      rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
      rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
      owl: 'http://www.w3.org/2002/07/owl#',
      foaf: 'http://xmlns.com/foaf/0.1/',
      org: 'https://www.w3.org/TR/vocab-org/',
      dc: 'http://purl.org/dc/elements/1.1/',
      xsd: 'http://www.w3.org/2001/XMLSchema#'
    };
  }

  private static isReactFlowNode(node: ReactFlowNode | Node): node is ReactFlowNode {
    return 'data' in node;
  }

  private static isReactFlowEdge(edge: ReactFlowEdge | Link): edge is ReactFlowEdge {
    return 'source' in edge && 'target' in edge;
  }

  static exportToTurtle(nodes: (ReactFlowNode | Node)[], edges: (ReactFlowEdge | Link)[], options: ExportOptions = {
    format: 'turtle',
    includeNamespaces: true,
    includeMetadata: true
  }): string {
    const namespaces = this.getNamespaces();
    let turtle = '';

    // Add namespace prefixes
    if (options.includeNamespaces) {
      Object.entries(namespaces).forEach(([prefix, uri]) => {
        turtle += `@prefix ${prefix}: <${uri}> .\n`;
      });
      turtle += '\n';
    }

    // Add metadata
    if (options.includeMetadata) {
      turtle += `# Knowledge Graph exported on ${new Date().toISOString()}\n`;
      turtle += `# Generated by VisGraph\n\n`;
    }

    // Export individuals/nodes
    nodes.forEach(node => {
      // Handle both  and React Flow formats
      const nodeData = this.isReactFlowNode(node) ? node.data : node;
      const { classType, individualName, namespace } = nodeData;
      const properties = 'literalProperties' in nodeData ? nodeData.literalProperties : [];
      
      const individualUri = `${namespace}:${String(individualName).replace(/\s+/g, '_')}`;
      const classUri = `${namespace}:${classType}`;
      
      turtle += `${individualUri} a ${classUri}`;
      
      // Add literal properties
      if (Array.isArray(properties) && properties.length > 0) {
        turtle += ' ;\n';
        properties.forEach((prop, index) => {
          const isLast = index === properties.length - 1;
          turtle += `    ${prop.key} "${prop.value}"`;
          turtle += isLast ? ' .\n\n' : ' ;\n';
        });
      } else {
        turtle += ' .\n\n';
      }
    });

    // Export relationships/edges
    edges.forEach(edge => {
      // Handle both  and React Flow formats
      const sourceId = this.isReactFlowEdge(edge) ? edge.source : edge.from;
      const targetId = this.isReactFlowEdge(edge) ? edge.target : edge.to;
      const propertyType = this.isReactFlowEdge(edge) ? edge.data?.propertyType : edge.propertyType;
      
      const sourceNode = nodes.find(n => {
        const nodeId = this.isReactFlowNode(n) ? n.id : n.key;
        return nodeId === sourceId;
      });
      const targetNode = nodes.find(n => {
        const nodeId = this.isReactFlowNode(n) ? n.id : n.key;
        return nodeId === targetId;
      });
      
      if (sourceNode && targetNode && propertyType) {
        const sourceData = this.isReactFlowNode(sourceNode) ? sourceNode.data : sourceNode;
        const targetData = this.isReactFlowNode(targetNode) ? targetNode.data : targetNode;
        
        const sourceUri = `${sourceData.namespace}:${String(sourceData.individualName).replace(/\s+/g, '_')}`;
        const targetUri = `${targetData.namespace}:${String(targetData.individualName).replace(/\s+/g, '_')}`;
        
        turtle += `${sourceUri} ${propertyType} ${targetUri} .\n`;
      }
    });

    return turtle;
  }

  static exportToOwlXml(nodes: (ReactFlowNode | Node)[], edges: (ReactFlowEdge | Link)[], options: ExportOptions = {
    format: 'owl-xml',
    includeNamespaces: true,
    includeMetadata: true
  }): string {
    const namespaces = this.getNamespaces();
    
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += '<rdf:RDF';
    
    // Add namespace declarations
    if (options.includeNamespaces) {
      Object.entries(namespaces).forEach(([prefix, uri]) => {
        xml += `\n    xmlns:${prefix}="${uri}"`;
      });
    }
    
    xml += '>\n\n';

    if (options.includeMetadata) {
      xml += `<!-- Knowledge Graph exported on ${new Date().toISOString()} -->\n`;
      xml += `<!-- Generated by VisGraph -->\n\n`;
    }

    // Export ontology header
    xml += '    <owl:Ontology rdf:about="">\n';
    xml += '        <rdfs:label>Exported Knowledge Graph</rdfs:label>\n';
    xml += `        <dc:created>${new Date().toISOString()}</dc:created>\n`;
    xml += '    </owl:Ontology>\n\n';

    // Export individuals
    nodes.forEach(node => {
      const nodeData = this.isReactFlowNode(node) ? node.data : node;
      const { classType, individualName, namespace } = nodeData;
      const properties = 'literalProperties' in nodeData ? nodeData.literalProperties : [];
      const individualId = String(individualName).replace(/\s+/g, '_');
      
      xml += `    <${namespace}:${classType} rdf:about="#${individualId}">\n`;
      
      properties.forEach(prop => {
        xml += `        <${prop.key}>${prop.value}</${prop.key}>\n`;
      });
      
      xml += `    </${namespace}:${classType}>\n\n`;
    });

    // Export object properties
    edges.forEach(edge => {
      const sourceId = this.isReactFlowEdge(edge) ? edge.source : edge.from;
      const targetId = this.isReactFlowEdge(edge) ? edge.target : edge.to;
      const propertyType = this.isReactFlowEdge(edge) ? edge.data?.propertyType : edge.propertyType;
      
      const sourceNode = nodes.find(n => {
        const nodeId = this.isReactFlowNode(n) ? n.id : n.key;
        return nodeId === sourceId;
      });
      const targetNode = nodes.find(n => {
        const nodeId = this.isReactFlowNode(n) ? n.id : n.key;
        return nodeId === targetId;
      });
      
      if (sourceNode && targetNode && propertyType) {
        const sourceData = this.isReactFlowNode(sourceNode) ? sourceNode.data : sourceNode;
        const targetData = this.isReactFlowNode(targetNode) ? targetNode.data : targetNode;
        const sourceIndividualId = String(sourceData.individualName).replace(/\s+/g, '_');
        const targetIndividualId = String(targetData.individualName).replace(/\s+/g, '_');
        const property = String(propertyType).split(':');
        
        xml += `    <owl:ObjectPropertyAssertion>\n`;
        xml += `        <owl:ObjectProperty IRI="#${property[1]}" />\n`;
        xml += `        <owl:NamedIndividual IRI="#${sourceIndividualId}" />\n`;
        xml += `        <owl:NamedIndividual IRI="#${targetIndividualId}" />\n`;
        xml += `    </owl:ObjectPropertyAssertion>\n\n`;
      }
    });

    xml += '</rdf:RDF>';
    return xml;
  }

  static exportToJsonLd(nodes: (ReactFlowNode | Node)[], edges: (ReactFlowEdge | Link)[], options: ExportOptions = {
    format: 'json-ld',
    includeNamespaces: true,
    includeMetadata: true
  }): string {
    const namespaces = this.getNamespaces();
    
    const jsonLd: any = {
      '@context': options.includeNamespaces ? namespaces : {},
      '@graph': []
    };

    if (options.includeMetadata) {
      jsonLd['@graph'].push({
        '@type': 'owl:Ontology',
        'rdfs:label': 'Exported Knowledge Graph',
        'dc:created': new Date().toISOString(),
        'dc:creator': 'VisGraph'
      });
    }

    // Export individuals
    nodes.forEach(node => {
      const nodeData = this.isReactFlowNode(node) ? node.data : node;
      const { classType, individualName, namespace } = nodeData;
      const properties = 'literalProperties' in nodeData ? nodeData.literalProperties : [];
      
      const individual: any = {
        '@id': `${namespace}:${String(individualName).replace(/\s+/g, '_')}`,
        '@type': `${namespace}:${classType}`
      };

      properties.forEach(prop => {
        individual[prop.key] = prop.value;
      });

      jsonLd['@graph'].push(individual);
    });

    // Export relationships
    edges.forEach(edge => {
      const sourceId = this.isReactFlowEdge(edge) ? edge.source : edge.from;
      const targetId = this.isReactFlowEdge(edge) ? edge.target : edge.to;
      const propertyType = this.isReactFlowEdge(edge) ? edge.data?.propertyType : edge.propertyType;
      
      const sourceNode = nodes.find(n => {
        const nodeId = this.isReactFlowNode(n) ? n.id : n.key;
        return nodeId === sourceId;
      });
      const targetNode = nodes.find(n => {
        const nodeId = this.isReactFlowNode(n) ? n.id : n.key;
        return nodeId === targetId;
      });
      
      if (sourceNode && targetNode && propertyType) {
        const sourceData = this.isReactFlowNode(sourceNode) ? sourceNode.data : sourceNode;
        const targetData = this.isReactFlowNode(targetNode) ? targetNode.data : targetNode;
        const sourceIndividualId = `${sourceData.namespace}:${String(sourceData.individualName).replace(/\s+/g, '_')}`;
        const targetIndividualId = `${targetData.namespace}:${String(targetData.individualName).replace(/\s+/g, '_')}`;
        
        // Find the source individual in the graph and add the relationship
        const sourceIndividual = jsonLd['@graph'].find((item: any) => item['@id'] === sourceIndividualId);
        if (sourceIndividual && propertyType) {
          sourceIndividual[String(propertyType)] = { '@id': targetIndividualId };
        }
      }
    });

    return JSON.stringify(jsonLd, null, 2);
  }

  static downloadFile(content: string, filename: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  static exportGraph(nodes: (ReactFlowNode | Node)[], edges: (ReactFlowEdge | Link)[], format: 'turtle' | 'owl-xml' | 'json-ld'): void {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    
    let content: string;
    let filename: string;
    let mimeType: string;

    switch (format) {
      case 'turtle':
        content = this.exportToTurtle(nodes, edges);
        filename = `knowledge-graph-${timestamp}.ttl`;
        mimeType = 'text/turtle';
        break;
      case 'owl-xml':
        content = this.exportToOwlXml(nodes, edges);
        filename = `knowledge-graph-${timestamp}.owl`;
        mimeType = 'application/rdf+xml';
        break;
      case 'json-ld':
        content = this.exportToJsonLd(nodes, edges);
        filename = `knowledge-graph-${timestamp}.jsonld`;
        mimeType = 'application/ld+json';
        break;
      default:
        throw new Error(`Unsupported format: ${format}`);
    }

    this.downloadFile(content, filename, mimeType);
  }
}

// Export function for direct use
export const exportGraph = async (nodes: (ReactFlowNode | Node)[], edges: (ReactFlowEdge | Link)[], format: 'turtle' | 'owl-xml' | 'json-ld'): Promise<string> => {
  switch (format) {
    case 'turtle':
      return GraphExporter.exportToTurtle(nodes, edges);
    case 'owl-xml':
      return GraphExporter.exportToOwlXml(nodes, edges);
    case 'json-ld':
      return GraphExporter.exportToJsonLd(nodes, edges);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
};