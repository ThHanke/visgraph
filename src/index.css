@config "../tailwind.config.ts";
@import 'tailwindcss';

/* Theme tokens (keep variables as single source of truth for light/dark) */
:root {
  /* Core Background */
  --background: oklch(98.4% 0.002 247.8);
  --foreground: oklch(37.5% 0.039 256.8);
  /* Stable dark foreground token for bright-button text (keeps same value across themes) */
  --text-foreground-dark: oklch(37.5% 0.039 256.8);
  /* Surface Colors */
  --card: oklch(100.0% 0 0);
  --card-foreground: oklch(37.5% 0.039 256.8);
  --popover: oklch(100.0% 0 0);
  --popover-foreground: oklch(37.5% 0.039 256.8);
  /* Brand Colors */
  --primary: oklch(67.5% 0.123 290.4);
  --primary-foreground: oklch(100.0% 0 0);
  --primary-hover: oklch(62.0% 0.145 289.1);
  --secondary: oklch(90.6% 0.035 173.4);
  --secondary-foreground: oklch(40.9% 0.049 170.3);
  --secondary-hover: oklch(87.5% 0.046 172.9);
  --accent: oklch(89.3% 0.056 57.5);
  --accent-foreground: oklch(38.3% 0.054 55.9);
  --accent-hover: oklch(85.9% 0.075 57.1);
  --muted: oklch(96.1% 0.004 247.9);
  --muted-foreground: oklch(58.3% 0.039 256.8);
  --destructive: oklch(75.8% 0.109 9.2);
  --destructive-foreground: oklch(100.0% 0 0);
  --border: oklch(90.6% 0.008 247.9);
  --input: oklch(93.7% 0.005 247.9);
  --ring: oklch(67.5% 0.123 290.4);
  --radius: 0.75rem;

  /* Canvas tokens */
  --canvas-bg: oklch(44.6% 0.03 256.802);
  --canvas-grid: oklch(92.9% 0.03 186.9);
  /* Node tokens */
  --node-bg: oklch(100.0% 0 0);
  --node-foreground: oklch(37.5% 0.039 256.8);
  --node-border: oklch(90.6% 0.008 247.9);
  --node-muted: oklch(93.7% 0.005 247.9);
  --node-shadow: 0 4px 20px oklch(0.3752 0.0394 256.8 / 0.1);
  --node-leftbar-width: 8px;

  /* Edge tokens */
  --edge-default: oklch(86.7% 0.041 256.8);
  --edge-selected: oklch(56.6% 0.166 287.5);
  /* Edge sizing (themeable) */
  --edge-width: 2.0px;
  --edge-marker-size: 16;
  /* Glassmorphism / animation variables */
  --glass-shadow: 0 8px 32px oklch(0.3752 0.0394 256.8 / 0.08);
  --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.dark {
  --background: oklch(18.7% 0.017 256.8);
  --foreground: oklch(96.1% 0.004 247.9);
  --card: oklch(23.0% 0.02 256.8);
  --card-foreground: oklch(96.1% 0.004 247.9);
  --popover: oklch(23.0% 0.02 256.8);
  --popover-foreground: oklch(96.1% 0.004 247.9);
  --primary: oklch(62.0% 0.145 289.1);
  --primary-foreground: oklch(100.0% 0 0);
  --muted: oklch(26.1% 0.024 256.8);
  --muted-foreground: oklch(82.3% 0.016 256.7);
  --border: oklch(38.8% 0.029 256.8);
  --input: oklch(29.2% 0.022 256.8);
  --canvas-bg: oklch(17.5% 0.008 186.6);
  --canvas-grid: oklch(22.4% 0.011 186.5);
  --node-bg: oklch(23.0% 0.02 256.8);
  --node-foreground: oklch(96.1% 0.004 247.9);
  --node-border: oklch(31.1% 0.025 256.8);
  --node-muted: oklch(26.1% 0.024 256.8);
  --node-shadow: 0 4px 20px oklch(0.1906 0.0105 248.4 / 0.12);
}

/* Minimal base layer: keep only what is required globally */
@layer base {
  * {
    border-color: var(--border);
  }

  body {
    /* @reference bg-background text-foreground; */
    font-family: 'Inter', system-ui, -apple-system, sans-serif;
  }

  /* Utility: explicit dark foreground for use on bright buttons / surfaces where text-foreground
     reads too light. This token intentionally does not change in .dark mode. */
  .text-foreground-dark { color: var(--text-foreground-dark); }
}

/* Low-level React Flow rules that are structural / interaction-critical and
   not practical to move into component-level Tailwind classes. These are
   intentionally minimal: keep SVG overflow visible and ensure controls positioning. */

/* Allow custom edge paths to render outside the SVG box */
.react-flow__edges svg {
  overflow: visible;
  position: absolute;
}


/* Keep controls visible above canvas; UI layer should use Tailwind classes where possible */
.react-flow__controls {
  z-index: 60;
  position: absolute;
  left: 8px;
  bottom: 8px;
  pointer-events: auto;
}

/* Minimal handle defaults kept here to avoid breaking pointer behavior.
   Visual styles (color, size) should be applied via Tailwind classes on node renderers
   or via CSS variables on the node elements. */
.react-flow__handle {
  transition: var(--transition-smooth);
}


/* Edge label renderer: keep transitions; let components control badge visuals (do not force solid styling here) */
.edge-label-renderer__custom-edge {
  position: absolute;
  transition: opacity 120ms linear, transform 120ms linear;
  /* will-change: opacity, transform; */
}

.node-bg {
  background: var(--node-bg);
}

.react-flow__node > * {
  /* background: var(--node-bg); */
  color: var(--node-foreground);
  /* border-color: var(--node-border); */
  box-shadow: var(--node-shadow);
}

/* Keep react-flow markers positioned */
.react-flow__marker {
  position: absolute;
}

/* Node badge helper: use the exact node-provided color (hex) via --node-color.
   The node renderer sets --node-color to the provided hex value so badges and left-bars
   reflect the node data exactly. Consumers that need derived tones should set additional
   CSS variables from JavaScript if required. */
.node-badge {
  background: var(--node-color, transparent);
  border: 1px solid var(--node-color, transparent);

  /* badge text color is set per-node with --node-badge-foreground (computed in JS) */
  color: var(--node-badge-foreground, var(--node-foreground));
}

/* Namespace dot: use exact namespace color provided via --ns-color (hex), fallback to transparent.
   This ensures legend swatches match node colors exactly. */
[data-ns-dot] {
  background: var(--ns-color, transparent);
  border: 1px solid color-mix(in srgb, var(--ns-color) 20%, var(--border));
}

/* Edge container fallback: allows using currentColor on SVG children for theme-aware strokes/fills */
.edge-container {
  color: var(--edge-default);
}

/* FloatingConnectionLine visuals: use currentColor and theme tokens for stroke/size */
.edge-container path {
  fill: none;
  stroke: currentColor;
  stroke-width: var(--edge-width);
}

.edge-container .edge-connection-circle {
  fill: currentColor;
  stroke: currentColor;
  stroke-width: calc(var(--edge-width) * 0.75);
}


/* .react-flow__handle.connectionindicator {
	opacity: 0;
}
.react-flow__handle-left {
  opacity: 0;
} */
.react-flow__panel {
  border-radius: var(--radius-md);
}

.react-flow__controls-button {
	border: none;
	color:  oklch(var(--muted-foreground) / var(--tw-text-opacity, 1));
  border: 1px solid var(--border);
  --tw-bg-opacity: 1;
  background-color: oklch(var(--muted) / var(--tw-bg-opacity, 1)) !important;
  }

.react-flow__controls-button svg {
    width: 100%;
    max-width: 18px;
    max-height: 18px;
    fill: var(--foreground)
  }
.react-flow__minimap {
  border: 1px solid var(--border);

  background-color: var(--canvas-bg)  !important;;
  /* background-color: oklch(var(--muted) / var(--tw-bg-opacity, 1)) !important; */
}

.react-flow__panel.bottom {
	bottom: 50px !important;
}

.react-flow__attribution {
	visibility: hidden;
}


/* Scope changes to the app canvas so these overrides are local and safe */
.knowledge-graph-canvas .react-flow__node.draggable {
  cursor: default; /* don't show grab cursor for whole node body */
}

/* Prefer showing pointer on handles so users can spot where to start a connection.
   Use !important sparingly to overcome inline utility classes that may set
   pointer-events or transparency. */


   .knowledge-graph-canvas .react-flow__handle {
  cursor: pointer !important;
  width: 100%;
  height: 100%;
  background: #00f;
  position: absolute;
  top: 0;
  left: 0;
  border-radius: var(--radius-md);
  transform: none;
  border: none;
  opacity: 0;
}

/* Slightly enlarge and highlight handle on node hover to make it discoverable */
.knowledge-graph-canvas .react-flow__node:hover .react-flow__handle {
  transform: scale(1.05);
  background: rgba(34,34,34,0.08);
  opacity: 1 !important;
}

/* Make sure connection-in-progress indicator remains obvious */
.knowledge-graph-canvas .react-flow__handle.connectionindicator {
  background: rgba(34,34,34,0.14) !important;
  border-color: rgba(34,34,34,0.2) !important;
}

/* Optional: extend clickable area without visually changing layout by using a pseudo element.
   This makes it easier to start a drag without changing node visuals. */
.knowledge-graph-canvas .react-flow__handle::after {
  content: "";
  position: absolute;
  left: -6px;
  top: -6px;
  right: -6px;
  bottom: -6px;
  border-radius: inherit;
  pointer-events: none; /* leave events to the handle itself */
}